{% extends "core/base.html" %}
{% load static %}
{% block title %}Escanear Código de Barras — Cámara e Imagen{% endblock %}

{% block content %}
<div class="container py-3" style="max-width:780px">
  <h3 class="mb-2">Escanear Código de Barras</h3>
  <p class="text-muted small">
    Usa la cámara o sube una imagen. Motor: <b>ZXing</b> con <i>fallback</i> a <b>Quagga</b>.
    Mantén el código <b>horizontal</b>, centrado en el marco y ocupando ~70% del ancho.
  </p>

  <!-- ===================== CÁMARA ===================== -->
  <h5 class="mt-3">Cámara</h5>

  <div class="mb-2">
    <label for="cameraSelect" class="form-label">Cámara</label>
    <select id="cameraSelect" class="form-select"></select>
  </div>

  <!-- El overlay vive dentro del MISMO contenedor que el video -->
  <div id="videoBox" class="ratio ratio-16x9 bg-dark rounded overflow-hidden position-relative mb-3">
    <video id="preview" muted playsinline class="w-100 h-100" style="object-fit: cover;"></video>

    <!-- Overlay: oculto por defecto; se muestra cuando la cámara queda lista -->
    <div id="scanOverlay"
         class="position-absolute w-100 h-100"
         style="inset:0; display:none; pointer-events:none;">
      <div class="overlay-mask position-absolute" style="inset:0;"></div>
      <div class="overlay-frame"></div>
      <div class="corner tl"></div>
      <div class="corner tr"></div>
      <div class="corner bl"></div>
      <div class="corner br"></div>
      <div class="overlay-line"></div>
    </div>
  </div>

  <style>
    :root { --roi-height: 30%; } /* igual que ROI_RATIO en JS */

    .overlay-mask {
      background:
        linear-gradient(to bottom,
          rgba(0,0,0,.45) calc((100% - var(--roi-height))/2),
          transparent calc((100% - var(--roi-height))/2),
          transparent calc((100% + var(--roi-height))/2),
          rgba(0,0,0,.45) calc((100% + var(--roi-height))/2)
        ),
        linear-gradient(to right,
          rgba(0,0,0,.15) 4%, transparent 4%,
          transparent 96%, rgba(0,0,0,.15) 96%
        );
    }
    .overlay-frame {
      position: absolute;
      left: 4%; right: 4%;
      top: calc((100% - var(--roi-height))/2);
      height: var(--roi-height);
      border: 2px dashed rgba(255,255,255,.75);
      border-radius: .5rem;
      box-shadow: 0 0 0 1px rgba(0,0,0,.25) inset;
    }
    .overlay-line {
      position: absolute; left: 4%; right: 4%;
      top: 50%; height: 2px;
      background: rgba(255,255,255,.65);
      transform: translateY(-1px);
    }
    .corner {
      position: absolute; width: 26px; height: 26px;
      border: 3px solid rgba(0,200,255,.95);
      filter: drop-shadow(0 0 4px rgba(0,0,0,.55));
    }
    .corner.tl { left: calc(4% - 3px); top: calc((100% - var(--roi-height))/2 - 3px); border-right:none; border-bottom:none; border-top-left-radius:10px; }
    .corner.tr { right: calc(4% - 3px); top: calc((100% - var(--roi-height))/2 - 3px); border-left:none; border-bottom:none; border-top-right-radius:10px; }
    .corner.bl { left: calc(4% - 3px); bottom: calc((100% - var(--roi-height))/2 - 3px); border-right:none; border-top:none; border-bottom-left-radius:10px; }
    .corner.br { right: calc(4% - 3px); bottom: calc((100% - var(--roi-height))/2 - 3px); border-left:none; border-top:none; border-bottom-right-radius:10px; }
  </style>

  <div class="d-flex flex-wrap gap-2 mb-3">
    <button id="btnPreview" class="btn btn-secondary">Vista previa</button>
    <button id="btnLive" class="btn btn-primary">Escanear en vivo</button>
    <button id="btnCapture" class="btn btn-outline-primary">Tomar imagen</button>
    <button id="btnPause" class="btn btn-outline-secondary" disabled>Pausar</button>
    <button id="btnRestart" class="btn btn-outline-dark" disabled>Reiniciar</button>
    <button id="btnTorch" class="btn btn-outline-dark d-none">Linterna</button>
  </div>

  <div id="result" class="alert alert-info d-none"></div>

  <details class="mt-2">
    <summary class="small text-muted">Diagnóstico</summary>
    <div class="small">
      <div>Estado: <span id="state">idle</span></div>
      <div>FPS aprox.: <span id="fps">0</span></div>
      <div>Último intento: <code id="lastTry">—</code></div>
    </div>
  </details>

  <hr class="my-4">

  <!-- ===================== SUBIR IMAGEN ===================== -->
  <h5>Subir imagen</h5>
  <p class="small text-muted">Sube una foto nítida del código (horizontal y ocupando gran parte de la imagen).</p>

  <div class="row g-3 align-items-end">
    <div class="col-md-8">
      <input id="fileInput" type="file" accept="image/*" class="form-control">
      <small id="fileName" class="text-muted d-block mt-1">Ningún archivo seleccionado.</small>
    </div>
    <div class="col-md-4 d-flex gap-2">
      <button id="btnReadImage" class="btn btn-outline-primary w-100" disabled>Leer imagen</button>
      <button id="btnClearImage" class="btn btn-outline-secondary">Limpiar</button>
    </div>
  </div>

  <div class="mt-3">
    <img id="previewImg" alt="Vista previa" class="img-fluid rounded d-none" />
  </div>
  <div id="resultImg" class="alert alert-info d-none mt-3"></div>
</div>

<!-- Librerías -->
<script src="https://unpkg.com/@zxing/library@0.21.3"></script>
<script src="https://unpkg.com/quagga2@1.8.4/dist/quagga.js"></script>

<script>
(function(){
  // ====== Parámetros ======
  const ROI_RATIO = 0.30;          // 30% del alto (coincide con CSS)
  const LIVE_INTERVAL_MS = 600;    // ms entre capturas en vivo
  const SCALE_MAX_W = 1200;        // ancho al reescalar
  const FALLBACK_EVERY = 4;        // cada N intentos, fallback amplio

  // ---------- Helpers ----------
  function show(el, msg, ok=true){ el.classList.remove('d-none','alert-info','alert-danger','alert-success'); el.classList.add(ok?'alert-success':'alert-danger'); el.textContent=msg; }
  function info(el, msg){ el.classList.remove('d-none','alert-success','alert-danger'); el.classList.add('alert-info'); el.textContent=msg; }
  function hide(el){ el.classList.add('d-none'); }
  function drawScaled(img, maxW){ const sc=Math.min(1,maxW/img.width); const w=Math.round(img.width*sc), h=Math.round(img.height*sc); const c=document.createElement('canvas'); c.width=w; c.height=h; c.getContext('2d').drawImage(img,0,0,w,h); return c; }

  function ensureVideoReady(vid){
    return new Promise(resolve=>{
      if (vid.readyState >= 2 && vid.videoWidth && vid.videoHeight) return resolve();
      const onReady = ()=>{ if (vid.videoWidth && vid.videoHeight) { vid.removeEventListener('loadedmetadata', onReady); resolve(); } };
      vid.addEventListener('loadedmetadata', onReady);
      requestAnimationFrame(onReady);
    });
  }

  function captureROIDataURL(vid){
    const vw = vid.videoWidth || 1280;
    const vh = vid.videoHeight || 720;
    const roiH = Math.floor(vh * ROI_RATIO);
    const y = Math.floor((vh - roiH) / 2);
    const canvas = document.createElement('canvas');
    canvas.width = vw; canvas.height = roiH;
    const ctx = canvas.getContext('2d');
    ctx.imageSmoothingEnabled = true;
    ctx.drawImage(vid, 0, y, vw, roiH, 0, 0, vw, roiH);
    return canvas.toDataURL('image/png');
  }

  async function tryZXingFromImage(img, formats){
    try{
      const hints = new Map(); const set=[];
      (formats||[]).forEach(f=> ZXing.BarcodeFormat[f] && set.push(ZXing.BarcodeFormat[f]));
      if(set.length) hints.set(ZXing.DecodeHintType.POSSIBLE_FORMATS, set);
      hints.set(ZXing.DecodeHintType.TRY_HARDER, true);
      const reader = new ZXing.BrowserMultiFormatReader();
      const res = await reader.decodeFromImage(img, hints).catch(()=>null);
      if(!res) return null;
      return (typeof res.getText==='function') ? res.getText() : (res.text||null);
    }catch(e){ console.warn("ZXing image error:", e); return null; }
  }

  function tryQuaggaFromCanvas(canvas){
    return new Promise(resolve=>{
      try{
        Quagga.decodeSingle({
          src: canvas.toDataURL("image/png"),
          numOfWorkers: 0,
          inputStream: { size: SCALE_MAX_W },
          decoder: { readers:["ean_reader","ean_8_reader","upc_reader","upc_e_reader","code_128_reader","code_39_reader"], multiple:false },
          locate: true
        }, res=> resolve(res && res.codeResult && res.codeResult.code ? res.codeResult.code : null));
      }catch(e){ console.warn("Quagga decode error:", e); resolve(null); }
    });
  }

  async function decodeDataURLTo(targetEl, label, dataUrl, fastMode=false){
    try{
      info(targetEl, `Procesando ${label}…`);
      lastTryEl.textContent = new Date().toLocaleTimeString();

      const img = await new Promise((resolve,reject)=>{ const i=new Image(); i.onload=()=>resolve(i); i.onerror=reject; i.src=dataUrl; });
      const canvas = drawScaled(img, SCALE_MAX_W);

      // ZXing rápido: EAN-13
      let code = await tryZXingFromImage(img, ["EAN_13"]);
      if (code){ show(targetEl, `Leído (${label}/ZXing): ${code}`, true); try{ if(navigator.vibrate) navigator.vibrate(30); }catch{}; console.log(`Captura (${label}/ZXing fast):`, code); return code; }

      const doWideFallback = !fastMode || (fastMode && (liveAttempt % FALLBACK_EVERY === 0));

      if (doWideFallback){
        code = await tryZXingFromImage(img, ["EAN_13","EAN_8","UPC_A","UPC_E","CODE_128","CODE_39"]);
        if (code){ show(targetEl, `Leído (${label}/ZXing+): ${code}`, true); try{ if(navigator.vibrate) navigator.vibrate(30); }catch{}; console.log(`Captura (${label}/ZXing wide):`, code); return code; }

        const q = await tryQuaggaFromCanvas(canvas);
        if (q){ show(targetEl, `Leído (${label}/Quagga): ${q}`, true); try{ if(navigator.vibrate) navigator.vibrate(30); }catch{}; console.log(`Captura (${label}/Quagga):`, q); return q; }
      }

      if (fastMode){
        info(targetEl, "Buscando… centra el código en el marco y manténlo firme.");
        return null;
      }

      show(targetEl, `No se pudo leer el código desde la ${label}. Ajusta encuadre/luz y reintenta.`, false);
      return null;
    }catch(err){
      console.error(err);
      show(targetEl, `Error procesando la ${label}. Revisa consola.`, false);
      return null;
    }
  }

  async function decodeImageDataURL(dataUrl){ await decodeDataURLTo(resultImg, "imagen", dataUrl, false); }

  // ---------- Cámara ----------
  const cameraSelect = document.getElementById('cameraSelect');
  const video = document.getElementById('preview');
  const overlay = document.getElementById('scanOverlay');

  const btnPreview = document.getElementById('btnPreview');
  const btnLive = document.getElementById('btnLive');
  const btnCapture = document.getElementById('btnCapture');
  const btnPause = document.getElementById('btnPause');
  const btnRestart = document.getElementById('btnRestart');
  const btnTorch = document.getElementById('btnTorch');

  const result = document.getElementById('result');
  const stateEl = document.getElementById('state');
  const fpsEl = document.getElementById('fps');
  const lastTryEl = document.getElementById('lastTry');

  let currentDeviceId = null;
  let trackWithTorch = null;
  let liveTimer = null;
  let fpsTimer = null;
  let isDecoding = false;
  let liveAttempt = 0;

  async function populateCameras(){
    try{ const s = await navigator.mediaDevices.getUserMedia({ video: true }); s.getTracks().forEach(t=>t.stop()); }catch(e){}
    const devices = await navigator.mediaDevices.enumerateDevices();
    const cams = devices.filter(d => d.kind === 'videoinput');
    cameraSelect.innerHTML = "";
    cams.forEach(d => {
      const opt = document.createElement('option');
      opt.value = d.deviceId || "";
      opt.textContent = d.label || `Cámara ${cameraSelect.length+1}`;
      cameraSelect.appendChild(opt);
    });
    if (cams[0]) currentDeviceId = cams[0].deviceId || null;
  }
  cameraSelect.onchange = e => currentDeviceId = e.target.value || null;

  function setState(s){ stateEl.textContent = s; }
  function setButtons(previewOn){ btnPreview.disabled=previewOn; btnRestart.disabled=previewOn; btnPause.disabled=!liveTimer; }

  function setupTorch(){
    const stream = video.srcObject;
    const tracks = stream ? stream.getVideoTracks() : [];
    trackWithTorch = tracks.find(t => t.getCapabilities && t.getCapabilities().torch);
    btnTorch.classList.toggle('d-none', !trackWithTorch);
  }

  async function startPreview(){
    stopLive(); hide(result); setState('iniciando cámara…');
    const constraints = currentDeviceId
      ? { video: { deviceId:{ exact: currentDeviceId }, width:{ideal:1920}, height:{ideal:1080}, focusMode:"continuous" } }
      : { video: { facingMode:"environment", width:{ideal:1920}, height:{ideal:1080}, focusMode:"continuous" } };
    try{
      const stream = await navigator.mediaDevices.getUserMedia(constraints);
      video.srcObject = stream;
      await video.play();
      await ensureVideoReady(video);
      setupTorch();

      overlay.style.display = '';            // mostrar marco ya alineado al contenedor
      setButtons(true);
      setState('preview');

      clearInterval(fpsTimer);
      let last = performance.now();
      fpsTimer = setInterval(()=>{
        const now = performance.now();
        const fps = 1000/(now-last);
        fpsEl.textContent = isFinite(fps) ? fps.toFixed(1) : "0";
        last = now;
      }, 1000);
    }catch(e){
      console.error(e);
      show(result, "No se pudo iniciar la cámara. Revisa permisos (HTTPS/localhost) y que no esté en uso.", false);
      overlay.style.display = 'none';
      setState('error');
    }
  }
  function stopPreview(){
    overlay.style.display = 'none';
    stopLive();
    if (video.srcObject){ video.srcObject.getTracks().forEach(t=>t.stop()); video.srcObject=null; }
    btnTorch.classList.add('d-none');
    clearInterval(fpsTimer);
    setButtons(false);
    setState('idle');
  }
  function stopLive(){ if(liveTimer){ clearInterval(liveTimer); liveTimer=null; } btnPause.disabled=true; }

  btnTorch.onclick = async ()=>{ if(!trackWithTorch) return; const on = !(trackWithTorch.getSettings().torch||false); try{ await trackWithTorch.applyConstraints({ advanced:[{ torch:on }] }); }catch(e){} };
  btnPreview.onclick = startPreview;
  btnRestart.onclick = async ()=>{ stopPreview(); await startPreview(); };

  btnCapture.onclick = async ()=>{
    if (!video.srcObject) await startPreview();
    await ensureVideoReady(video);
    const dataUrl = captureROIDataURL(video);
    await decodeDataURLTo(result, "captura", dataUrl, false);
  };

  btnLive.onclick = async ()=>{
    if (!video.srcObject) await startPreview();
    await ensureVideoReady(video);
    if (liveTimer) return;
    liveAttempt = 0;
    setState('live'); btnPause.disabled = true;
    setTimeout(()=>{ btnPause.disabled = false; }, 500); // warm-up

    liveTimer = setInterval(async ()=>{
      if (isDecoding) return;
      isDecoding = true;
      try{
        const dataUrl = captureROIDataURL(video);
        const code = await decodeDataURLTo(result, "captura", dataUrl, true);
        liveAttempt++;
        if (code){ stopLive(); setState('preview'); }
      } finally { isDecoding = false; }
    }, LIVE_INTERVAL_MS);
  };
  btnPause.onclick = ()=>{ stopLive(); setState(video.srcObject ? 'preview':'idle'); };

  // ---------- Subir imagen ----------
  const fileInput=document.getElementById('fileInput');
  const btnReadImage=document.getElementById('btnReadImage');
  const btnClearImage=document.getElementById('btnClearImage');
  const previewImg=document.getElementById('previewImg');
  const resultImg=document.getElementById('resultImg');
  const fileName=document.getElementById('fileName');

  fileInput.addEventListener('change', ()=>{
    hide(resultImg);
    const f = fileInput.files && fileInput.files[0];
    if(!f){
      fileName.textContent='Ningún archivo seleccionado.';
      previewImg.src='';
      previewImg.classList.add('d-none');
      btnReadImage.disabled=true;
      return;
    }
    fileName.textContent=f.name;
    const rd = new FileReader();
    rd.onload = (e)=>{
      const dataUrl=e.target.result;
      previewImg.src=dataUrl;
      previewImg.classList.remove('d-none');
      btnReadImage.disabled=false;
      // lectura automática al seleccionar
      decodeImageDataURL(dataUrl);
    };
    rd.readAsDataURL(f);
  });
  btnReadImage.addEventListener('click', ()=>{
    const f = fileInput.files && fileInput.files[0];
    if(!f){ show(resultImg,"Primero selecciona una imagen.",false); return; }
    const rd=new FileReader();
    rd.onload=(e)=>decodeImageDataURL(e.target.result);
    rd.readAsDataURL(f);
  });
  btnClearImage.addEventListener('click', ()=>{
    fileInput.value='';
    fileName.textContent='Ningún archivo seleccionado.';
    previewImg.src='';
    previewImg.classList.add('d-none');
    hide(resultImg);
    btnReadImage.disabled=true;
  });

  async function decodeImageDataURL(dataUrl){ await decodeDataURLTo(resultImg, "imagen", dataUrl, false); }

  // ---------- Atajo teclado ----------
  document.addEventListener('keydown', (e)=>{ if(e.key==='Enter'){ btnCapture.click(); } });

  // ---------- Inicio ----------
  populateCameras();
})();
</script>
{% endblock %}
